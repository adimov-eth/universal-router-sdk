{"version":3,"file":"universal-router-sdk.cjs.production.min.js","sources":["../src/entities/Command.ts","../src/entities/NFTTrade.ts","../src/utils/routerCommands.ts","../src/utils/constants.ts","../src/entities/protocols/uniswap.ts","../src/utils/numbers.ts","../src/utils/inputTokens.ts","../src/swapRouter.ts","../src/entities/protocols/cryptopunk.ts","../src/entities/protocols/foundation.ts","../src/entities/protocols/looksRareV2.ts","../src/entities/protocols/nft20.ts","../src/entities/protocols/nftx.ts","../src/entities/protocols/seaport.ts","../src/entities/protocols/sudoswap.ts","../src/entities/protocols/x2y2.ts","../src/utils/routerTradeAdapter.ts","../src/entities/protocols/unwrapWETH.ts"],"sourcesContent":["import { RoutePlanner } from '../utils/routerCommands'\n\nexport type TradeConfig = {\n  allowRevert: boolean\n}\n\nexport enum RouterTradeType {\n  UniswapTrade = 'UniswapTrade',\n  NFTTrade = 'NFTTrade',\n  UnwrapWETH = 'UnwrapWETH',\n}\n\n// interface for entities that can be encoded as a Universal Router command\nexport interface Command {\n  tradeType: RouterTradeType\n  encode(planner: RoutePlanner, config: TradeConfig): void\n}\n","import invariant from 'tiny-invariant'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { SeaportData } from './protocols/seaport'\nimport { FoundationData } from './protocols/foundation'\nimport { NFTXData } from './protocols/nftx'\nimport { NFT20Data } from './protocols/nft20'\nimport { RoutePlanner } from '../utils/routerCommands'\nimport { Command, RouterTradeType, TradeConfig } from './Command'\nimport { SudoswapData } from './protocols/sudoswap'\nimport { CryptopunkData } from './protocols/cryptopunk'\nimport { X2Y2Data } from './protocols/x2y2'\nimport { ElementData } from './protocols/element-market'\nimport { LooksRareV2Data } from './protocols/looksRareV2'\n\nexport type SupportedProtocolsData =\n  | SeaportData\n  | FoundationData\n  | NFTXData\n  | LooksRareV2Data\n  | X2Y2Data\n  | CryptopunkData\n  | NFT20Data\n  | SudoswapData\n  | ElementData\n\nexport abstract class NFTTrade<T> implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.NFTTrade\n  readonly orders: T[]\n  readonly market: Market\n\n  constructor(market: Market, orders: T[]) {\n    invariant(orders.length > 0, 'no buy Items')\n    this.market = market\n    this.orders = orders\n  }\n\n  abstract encode(planner: RoutePlanner, config: TradeConfig): void\n\n  abstract getBuyItems(): BuyItem[]\n\n  // optional parameter for the markets that accept ERC20s not just ETH\n  abstract getTotalPrice(token?: string): BigNumber\n}\n\nexport type BuyItem = {\n  tokenAddress: string\n  tokenId: BigNumberish\n  tokenType: TokenType\n  amount?: BigNumberish // for 1155\n}\n\nexport enum Market {\n  Foundation = 'foundation',\n  LooksRareV2 = 'looksrareV2',\n  NFT20 = 'nft20',\n  NFTX = 'nftx',\n  Seaport = 'seaport',\n  Sudoswap = 'Sudoswap',\n  Cryptopunks = 'cryptopunks',\n  X2Y2 = 'x2y2',\n  Element = 'element',\n}\n\nexport enum TokenType {\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155',\n  Cryptopunk = 'Cryptopunk',\n}\n","import { defaultAbiCoder } from 'ethers/lib/utils'\n\n/**\n * CommandTypes\n * @description Flags that modify a command's execution\n * @enum {number}\n */\nexport enum CommandType {\n  V3_SWAP_EXACT_IN = 0x00,\n  V3_SWAP_EXACT_OUT = 0x01,\n  PERMIT2_TRANSFER_FROM = 0x02,\n  PERMIT2_PERMIT_BATCH = 0x03,\n  SWEEP = 0x04,\n  TRANSFER = 0x05,\n  PAY_PORTION = 0x06,\n\n  V2_SWAP_EXACT_IN = 0x08,\n  V2_SWAP_EXACT_OUT = 0x09,\n  PERMIT2_PERMIT = 0x0a,\n  WRAP_ETH = 0x0b,\n  UNWRAP_WETH = 0x0c,\n  PERMIT2_TRANSFER_FROM_BATCH = 0x0d,\n  BALANCE_CHECK_ERC20 = 0x0e,\n\n  // NFT-related command types\n  SEAPORT_V1_5 = 0x10,\n  LOOKS_RARE_V2 = 0x11,\n  NFTX = 0x12,\n  CRYPTOPUNKS = 0x13,\n  // 0x14\n  OWNER_CHECK_721 = 0x15,\n  OWNER_CHECK_1155 = 0x16,\n  SWEEP_ERC721 = 0x17,\n\n  X2Y2_721 = 0x18,\n  SUDOSWAP = 0x19,\n  NFT20 = 0x1a,\n  X2Y2_1155 = 0x1b,\n  FOUNDATION = 0x1c,\n  SWEEP_ERC1155 = 0x1d,\n  ELEMENT_MARKET = 0x1e,\n\n  SEAPORT_V1_4 = 0x20,\n  EXECUTE_SUB_PLAN = 0x21,\n  APPROVE_ERC20 = 0x22,\n}\n\nconst ALLOW_REVERT_FLAG = 0x80\n\nconst REVERTIBLE_COMMANDS = new Set<CommandType>([\n  CommandType.SEAPORT_V1_5,\n  CommandType.SEAPORT_V1_4,\n  CommandType.NFTX,\n  CommandType.LOOKS_RARE_V2,\n  CommandType.X2Y2_721,\n  CommandType.X2Y2_1155,\n  CommandType.FOUNDATION,\n  CommandType.SUDOSWAP,\n  CommandType.NFT20,\n  CommandType.EXECUTE_SUB_PLAN,\n  CommandType.CRYPTOPUNKS,\n  CommandType.ELEMENT_MARKET,\n])\n\nconst PERMIT_STRUCT =\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce) details,address spender,uint256 sigDeadline)'\n\nconst PERMIT_BATCH_STRUCT =\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce)[] details,address spender,uint256 sigDeadline)'\n\nconst PERMIT2_TRANSFER_FROM_STRUCT = '(address from,address to,uint160 amount,address token)'\nconst PERMIT2_TRANSFER_FROM_BATCH_STRUCT = PERMIT2_TRANSFER_FROM_STRUCT + '[]'\n\nconst ABI_DEFINITION: { [key in CommandType]: string[] } = {\n  // Batch Reverts\n  [CommandType.EXECUTE_SUB_PLAN]: ['bytes', 'bytes[]'],\n\n  // Permit2 Actions\n  [CommandType.PERMIT2_PERMIT]: [PERMIT_STRUCT, 'bytes'],\n  [CommandType.PERMIT2_PERMIT_BATCH]: [PERMIT_BATCH_STRUCT, 'bytes'],\n  [CommandType.PERMIT2_TRANSFER_FROM]: ['address', 'address', 'uint160'],\n  [CommandType.PERMIT2_TRANSFER_FROM_BATCH]: [PERMIT2_TRANSFER_FROM_BATCH_STRUCT],\n\n  // Uniswap Actions\n  [CommandType.V3_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\n  [CommandType.V3_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\n  [CommandType.V2_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\n  [CommandType.V2_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\n\n  // Token Actions and Checks\n  [CommandType.WRAP_ETH]: ['address', 'uint256'],\n  [CommandType.UNWRAP_WETH]: ['address', 'uint256'],\n  [CommandType.SWEEP]: ['address', 'address', 'uint256'],\n  [CommandType.SWEEP_ERC721]: ['address', 'address', 'uint256'],\n  [CommandType.SWEEP_ERC1155]: ['address', 'address', 'uint256', 'uint256'],\n  [CommandType.TRANSFER]: ['address', 'address', 'uint256'],\n  [CommandType.PAY_PORTION]: ['address', 'address', 'uint256'],\n  [CommandType.BALANCE_CHECK_ERC20]: ['address', 'address', 'uint256'],\n  [CommandType.OWNER_CHECK_721]: ['address', 'address', 'uint256'],\n  [CommandType.OWNER_CHECK_1155]: ['address', 'address', 'uint256', 'uint256'],\n  [CommandType.APPROVE_ERC20]: ['address', 'uint256'],\n\n  // NFT Markets\n  [CommandType.SEAPORT_V1_5]: ['uint256', 'bytes'],\n  [CommandType.SEAPORT_V1_4]: ['uint256', 'bytes'],\n  [CommandType.NFTX]: ['uint256', 'bytes'],\n  [CommandType.LOOKS_RARE_V2]: ['uint256', 'bytes'],\n  [CommandType.X2Y2_721]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.X2Y2_1155]: ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'],\n  [CommandType.FOUNDATION]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.SUDOSWAP]: ['uint256', 'bytes'],\n  [CommandType.NFT20]: ['uint256', 'bytes'],\n  [CommandType.CRYPTOPUNKS]: ['uint256', 'address', 'uint256'],\n  [CommandType.ELEMENT_MARKET]: ['uint256', 'bytes'],\n}\n\nexport class RoutePlanner {\n  commands: string\n  inputs: string[]\n\n  constructor() {\n    this.commands = '0x'\n    this.inputs = []\n  }\n\n  addSubPlan(subplan: RoutePlanner): void {\n    this.addCommand(CommandType.EXECUTE_SUB_PLAN, [subplan.commands, subplan.inputs], true)\n  }\n\n  addCommand(type: CommandType, parameters: any[], allowRevert = false): void {\n    let command = createCommand(type, parameters)\n    this.inputs.push(command.encodedInput)\n    if (allowRevert) {\n      if (!REVERTIBLE_COMMANDS.has(command.type)) {\n        throw new Error(`command type: ${command.type} cannot be allowed to revert`)\n      }\n      command.type = command.type | ALLOW_REVERT_FLAG\n    }\n\n    this.commands = this.commands.concat(command.type.toString(16).padStart(2, '0'))\n  }\n}\n\nexport type RouterCommand = {\n  type: CommandType\n  encodedInput: string\n}\n\nexport function createCommand(type: CommandType, parameters: any[]): RouterCommand {\n  const encodedInput = defaultAbiCoder.encode(ABI_DEFINITION[type], parameters)\n  return { type, encodedInput }\n}\n","import { BigNumber } from 'ethers'\n\ntype ChainConfig = {\n  router: string\n  creationBlock: number\n  weth: string\n}\n\nconst WETH_NOT_SUPPORTED_ON_CHAIN = '0x0000000000000000000000000000000000000000'\n\nconst CHAIN_CONFIGS: { [key: number]: ChainConfig } = {\n  //auroria\n  [205205]: {\n    router: '0xfcEeF4e799E4dC0FDa88cEdfE700d626f91D2da6',\n    weth: '0x7b7E6F779c497df2e9EAF8C311d44A296E4F316D',\n    creationBlock: 598001,\n  },\n  // mainnet\n  [1]: {\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\n    weth: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n    creationBlock: 17143817,\n  },\n  // goerli\n  [5]: {\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\n    weth: '0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6',\n    creationBlock: 8940568,\n  },\n  // sepolia\n  [11155111]: {\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\n    weth: '0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14',\n    creationBlock: 3543575,\n  },\n  // polygon\n  [137]: {\n    router: '0xec7BE89e9d109e7e3Fec59c222CF297125FEFda2',\n    weth: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270',\n    creationBlock: 52210153,\n  },\n  //polygon mumbai\n  [80001]: {\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\n    weth: '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889',\n    creationBlock: 35176052,\n  },\n  //optimism\n  [10]: {\n    router: '0xCb1355ff08Ab38bBCE60111F1bb2B784bE25D7e8',\n    weth: '0x4200000000000000000000000000000000000006',\n    creationBlock: 114702266,\n  },\n  // optimism goerli\n  [420]: {\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\n    weth: '0x4200000000000000000000000000000000000006',\n    creationBlock: 8887728,\n  },\n  // arbitrum\n  [42161]: {\n    router: '0x5E325eDA8064b456f4781070C0738d849c824258',\n    weth: '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1',\n    creationBlock: 169472836,\n  },\n  // arbitrum goerli\n  [421613]: {\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\n    weth: '0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3',\n    creationBlock: 18815277,\n  },\n  // celo\n  [42220]: {\n    router: '0x643770e279d5d0733f21d6dc03a8efbabf3255b4',\n    weth: WETH_NOT_SUPPORTED_ON_CHAIN,\n    creationBlock: 21407637,\n  },\n  // celo alfajores\n  [44787]: {\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\n    weth: WETH_NOT_SUPPORTED_ON_CHAIN,\n    creationBlock: 17566658,\n  },\n  // binance smart chain\n  [56]: {\n    router: '0x4Dae2f939ACf50408e13d58534Ff8c2776d45265',\n    weth: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n    creationBlock: 35160263,\n  },\n  // avalanche\n  [43114]: {\n    router: '0x4Dae2f939ACf50408e13d58534Ff8c2776d45265',\n    weth: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',\n    creationBlock: 40237257,\n  },\n  // base goerli\n  [84531]: {\n    router: '0xd0872d928672ae2ff74bdb2f5130ac12229cafaf',\n    weth: '0x4200000000000000000000000000000000000006',\n    creationBlock: 6915289,\n  },\n  // base mainnet\n  [8453]: {\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\n    weth: '0x4200000000000000000000000000000000000006',\n    creationBlock: 9107268,\n  },\n  [81457]: {\n    router: '0x643770E279d5D0733F21d6DC03A8efbABf3255B4',\n    weth: '0x4300000000000000000000000000000000000004',\n    creationBlock: 1116444,\n  },\n  [7777777]: {\n    router: '0x2986d9721A49838ab4297b695858aF7F17f38014',\n    weth: '0x4200000000000000000000000000000000000006',\n    creationBlock: 11832155,\n  },\n  [324]: {\n    router: '0x28731BCC616B5f51dD52CF2e4dF0E78dD1136C06',\n    weth: '0x5aea5775959fbc2557cc8789bc1bf90a239d9a91',\n    creationBlock: 12640979,\n  },\n}\n\nexport const UNIVERSAL_ROUTER_ADDRESS = (chainId: number): string => {\n  if (!(chainId in CHAIN_CONFIGS)) throw new Error(`Universal Router not deployed on chain ${chainId}`)\n  return CHAIN_CONFIGS[chainId].router\n}\n\nexport const UNIVERSAL_ROUTER_CREATION_BLOCK = (chainId: number): number => {\n  if (!(chainId in CHAIN_CONFIGS)) throw new Error(`Universal Router not deployed on chain ${chainId}`)\n  return CHAIN_CONFIGS[chainId].creationBlock\n}\n\nexport const WETH_ADDRESS = (chainId: number): string => {\n  if (!(chainId in CHAIN_CONFIGS)) throw new Error(`Universal Router not deployed on chain ${chainId}`)\n\n  if (CHAIN_CONFIGS[chainId].weth == WETH_NOT_SUPPORTED_ON_CHAIN) throw new Error(`Chain ${chainId} does not have WETH`)\n\n  return CHAIN_CONFIGS[chainId].weth\n}\n\nexport const PERMIT2_ADDRESS = '0xd6A77B342771c3fcc0CF40B441533B94D6596C7c'\n\nexport const CONTRACT_BALANCE = BigNumber.from(2).pow(255)\nexport const ETH_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const E_ETH_ADDRESS = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'\nexport const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const MAX_UINT256 = BigNumber.from(2).pow(256).sub(1)\nexport const MAX_UINT160 = BigNumber.from(2).pow(160).sub(1)\n\nexport const SENDER_AS_RECIPIENT = '0x0000000000000000000000000000000000000001'\nexport const ROUTER_AS_RECIPIENT = '0x0000000000000000000000000000000000000002'\n\nexport const OPENSEA_CONDUIT_SPENDER_ID = 0\nexport const SUDOSWAP_SPENDER_ID = 1\n","import { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { Trade as V2Trade, Pair } from '@uniswap/v2-sdk'\nimport { Trade as V3Trade, Pool, encodeRouteToPath } from '@uniswap/v3-sdk'\nimport {\n  Trade as RouterTrade,\n  MixedRouteTrade,\n  Protocol,\n  IRoute,\n  RouteV2,\n  RouteV3,\n  MixedRouteSDK,\n  MixedRoute,\n  SwapOptions as RouterSwapOptions,\n  getOutputOfPools,\n  encodeMixedRouteToPath,\n  partitionMixedRouteByProtocol,\n} from '@uniswap/router-sdk'\nimport { Permit2Permit } from '../../utils/inputTokens'\nimport { Currency, TradeType, CurrencyAmount, Percent } from '@uniswap/sdk-core'\nimport { Command, RouterTradeType, TradeConfig } from '../Command'\nimport { SENDER_AS_RECIPIENT, ROUTER_AS_RECIPIENT, CONTRACT_BALANCE, ETH_ADDRESS } from '../../utils/constants'\nimport { encodeFeeBips } from '../../utils/numbers'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type FlatFeeOptions = {\n  amount: BigNumberish\n  recipient: string\n}\n\n// the existing router permit object doesn't include enough data for permit2\n// so we extend swap options with the permit2 permit\n// when safe mode is enabled, the SDK will add an extra ETH sweep for security\n// when useRouterBalance is enabled the SDK will use the balance in the router for the swap\nexport type SwapOptions = Omit<RouterSwapOptions, 'inputTokenPermit'> & {\n  useRouterBalance?: boolean\n  inputTokenPermit?: Permit2Permit\n  flatFee?: FlatFeeOptions\n  safeMode?: boolean\n}\n\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(50, 100)\n\ninterface Swap<TInput extends Currency, TOutput extends Currency> {\n  route: IRoute<TInput, TOutput, Pair | Pool>\n  inputAmount: CurrencyAmount<TInput>\n  outputAmount: CurrencyAmount<TOutput>\n}\n\n// Wrapper for uniswap router-sdk trade entity to encode swaps for Universal Router\n// also translates trade objects from previous (v2, v3) SDKs\nexport class UniswapTrade implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.UniswapTrade\n  readonly payerIsUser: boolean\n\n  constructor(public trade: RouterTrade<Currency, Currency, TradeType>, public options: SwapOptions) {\n    if (!!options.fee && !!options.flatFee) throw new Error('Only one fee option permitted')\n\n    if (this.inputRequiresWrap) this.payerIsUser = false\n    else if (this.options.useRouterBalance) this.payerIsUser = false\n    else this.payerIsUser = true\n  }\n\n  get inputRequiresWrap(): boolean {\n    return this.trade.inputAmount.currency.isNative\n  }\n\n  encode(planner: RoutePlanner, _config: TradeConfig): void {\n    // If the input currency is the native currency, we need to wrap it with the router as the recipient\n    if (this.inputRequiresWrap) {\n      // TODO: optimize if only one v2 pool we can directly send this to the pool\n      planner.addCommand(CommandType.WRAP_ETH, [\n        ROUTER_AS_RECIPIENT,\n        this.trade.maximumAmountIn(this.options.slippageTolerance).quotient.toString(),\n      ])\n    }\n    // The overall recipient at the end of the trade, SENDER_AS_RECIPIENT uses the msg.sender\n    this.options.recipient = this.options.recipient ?? SENDER_AS_RECIPIENT\n\n    // flag for whether we want to perform slippage check on aggregate output of multiple routes\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck =\n      this.trade.tradeType === TradeType.EXACT_INPUT && this.trade.routes.length > 2\n    const outputIsNative = this.trade.outputAmount.currency.isNative\n    const routerMustCustody = performAggregatedSlippageCheck || outputIsNative || hasFeeOption(this.options)\n\n    for (const swap of this.trade.swaps) {\n      switch (swap.route.protocol) {\n        case Protocol.V2:\n          addV2Swap(planner, swap, this.trade.tradeType, this.options, this.payerIsUser, routerMustCustody)\n          break\n        case Protocol.V3:\n          addV3Swap(planner, swap, this.trade.tradeType, this.options, this.payerIsUser, routerMustCustody)\n          break\n        case Protocol.MIXED:\n          addMixedSwap(planner, swap, this.trade.tradeType, this.options, this.payerIsUser, routerMustCustody)\n          break\n        default:\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL')\n      }\n    }\n\n    let minimumAmountOut: BigNumber = BigNumber.from(\n      this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString()\n    )\n\n    // The router custodies for 3 reasons: to unwrap, to take a fee, and/or to do a slippage check\n    if (routerMustCustody) {\n      // If there is a fee, that percentage is sent to the fee recipient\n      // In the case where ETH is the output currency, the fee is taken in WETH (for gas reasons)\n      if (!!this.options.fee) {\n        const feeBips = encodeFeeBips(this.options.fee.fee)\n        planner.addCommand(CommandType.PAY_PORTION, [\n          this.trade.outputAmount.currency.wrapped.address,\n          this.options.fee.recipient,\n          feeBips,\n        ])\n\n        // If the trade is exact output, and a fee was taken, we must adjust the amount out to be the amount after the fee\n        // Otherwise we continue as expected with the trade's normal expected output\n        if (this.trade.tradeType === TradeType.EXACT_OUTPUT) {\n          minimumAmountOut = minimumAmountOut.sub(minimumAmountOut.mul(feeBips).div(10000))\n        }\n      }\n\n      // If there is a flat fee, that absolute amount is sent to the fee recipient\n      // In the case where ETH is the output currency, the fee is taken in WETH (for gas reasons)\n      if (!!this.options.flatFee) {\n        const feeAmount = this.options.flatFee.amount\n        if (minimumAmountOut.lt(feeAmount)) throw new Error('Flat fee amount greater than minimumAmountOut')\n\n        planner.addCommand(CommandType.TRANSFER, [\n          this.trade.outputAmount.currency.wrapped.address,\n          this.options.flatFee.recipient,\n          feeAmount,\n        ])\n\n        // If the trade is exact output, and a fee was taken, we must adjust the amount out to be the amount after the fee\n        // Otherwise we continue as expected with the trade's normal expected output\n        if (this.trade.tradeType === TradeType.EXACT_OUTPUT) {\n          minimumAmountOut = minimumAmountOut.sub(feeAmount)\n        }\n      }\n\n      // The remaining tokens that need to be sent to the user after the fee is taken will be caught\n      // by this if-else clause.\n      if (outputIsNative) {\n        planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, minimumAmountOut])\n      } else {\n        planner.addCommand(CommandType.SWEEP, [\n          this.trade.outputAmount.currency.wrapped.address,\n          this.options.recipient,\n          minimumAmountOut,\n        ])\n      }\n    }\n\n    if (this.inputRequiresWrap && (this.trade.tradeType === TradeType.EXACT_OUTPUT || riskOfPartialFill(this.trade))) {\n      // for exactOutput swaps that take native currency as input\n      // we need to send back the change to the user\n      planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, 0])\n    }\n\n    if (this.options.safeMode) planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, this.options.recipient, 0])\n  }\n}\n\n// encode a uniswap v2 swap\nfunction addV2Swap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const trade = new V2Trade(\n    //@ts-ignore\n    route as RouteV2<TInput, TOutput>,\n    tradeType == TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n    tradeType\n  )\n\n  if (tradeType == TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n      // if native, we have to unwrap so keep in the router for now\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      route.path.map((pool) => pool.address),\n      payerIsUser,\n    ])\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_OUT, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      route.path.map((pool) => pool.address),\n      payerIsUser,\n    ])\n  }\n}\n\n// encode a uniswap v3 swap\nfunction addV3Swap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const trade = V3Trade.createUncheckedTrade({\n    route: route as RouteV3<TInput, TOutput>,\n    inputAmount,\n    outputAmount,\n    tradeType,\n  })\n\n  const path = encodeRouteToPath(route as RouteV3<TInput, TOutput>, trade.tradeType === TradeType.EXACT_OUTPUT)\n  if (tradeType == TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      path,\n      payerIsUser,\n    ])\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_OUT, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      path,\n      payerIsUser,\n    ])\n  }\n}\n\n// encode a mixed route swap, i.e. including both v2 and v3 pools\nfunction addMixedSwap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  swap: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const { route, inputAmount, outputAmount } = swap\n  const tradeRecipient = routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient\n\n  // single hop, so it can be reduced to plain v2 or v3 swap logic\n  if (route.pools.length === 1) {\n    if (route.pools[0] instanceof Pool) {\n      return addV3Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\n    } else if (route.pools[0] instanceof Pair) {\n      return addV2Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\n    } else {\n      throw new Error('Invalid route type')\n    }\n  }\n\n  const trade = MixedRouteTrade.createUncheckedTrade({\n    route: route as MixedRoute<TInput, TOutput>,\n    inputAmount,\n    outputAmount,\n    tradeType,\n  })\n\n  const amountIn = trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient.toString()\n  const amountOut = trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient.toString()\n\n  // logic from\n  // https://github.com/Uniswap/router-sdk/blob/d8eed164e6c79519983844ca8b6a3fc24ebcb8f8/src/swapRouter.ts#L276\n  const sections = partitionMixedRouteByProtocol(route as MixedRoute<TInput, TOutput>)\n  const isLastSectionInRoute = (i: number) => {\n    return i === sections.length - 1\n  }\n\n  let outputToken\n  let inputToken = route.input.wrapped\n\n  for (let i = 0; i < sections.length; i++) {\n    const section = sections[i]\n    /// Now, we get output of this section\n    outputToken = getOutputOfPools(section, inputToken)\n\n    const newRouteOriginal = new MixedRouteSDK(\n      [...section],\n      section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1,\n      outputToken\n    )\n    const newRoute = new MixedRoute(newRouteOriginal)\n\n    /// Previous output is now input\n    inputToken = outputToken\n\n    const mixedRouteIsAllV3 = (route: MixedRouteSDK<Currency, Currency>) => {\n      return route.pools.every((pool) => pool instanceof Pool)\n    }\n\n    if (mixedRouteIsAllV3(newRoute)) {\n      const path: string = encodeMixedRouteToPath(newRoute)\n\n      planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n        // if not last section: send tokens directly to the first v2 pair of the next section\n        // note: because of the partitioning function we can be sure that the next section is v2\n        isLastSectionInRoute(i) ? tradeRecipient : (sections[i + 1][0] as Pair).liquidityToken.address,\n        i == 0 ? amountIn : CONTRACT_BALANCE, // amountIn\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOut\n        path, // path\n        payerIsUser && i === 0, // payerIsUser\n      ])\n    } else {\n      planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n        isLastSectionInRoute(i) ? tradeRecipient : ROUTER_AS_RECIPIENT, // recipient\n        i === 0 ? amountIn : CONTRACT_BALANCE, // amountIn\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOutMin\n        newRoute.path.map((pool) => pool.address), // path\n        payerIsUser && i === 0,\n      ])\n    }\n  }\n}\n\n// if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\nfunction riskOfPartialFill(trade: RouterTrade<Currency, Currency, TradeType>): boolean {\n  return trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\n}\n\nfunction hasFeeOption(swapOptions: SwapOptions): boolean {\n  return !!swapOptions.fee || !!swapOptions.flatFee\n}\n","import { BigNumber } from 'ethers'\nimport JSBI from 'jsbi'\nimport bn from 'bignumber.js'\nimport { Percent } from '@uniswap/sdk-core'\nimport { toHex } from '@uniswap/v3-sdk'\n\nexport function expandTo18DecimalsBN(n: number): BigNumber {\n  // use bn intermediately to allow decimals in intermediate calculations\n  return BigNumber.from(new bn(n).times(new bn(10).pow(18)).toFixed())\n}\n\nexport function expandTo18Decimals(n: number): JSBI {\n  return JSBI.BigInt(BigNumber.from(n).mul(BigNumber.from(10).pow(18)).toString())\n}\n\nexport function encodeFeeBips(fee: Percent): string {\n  return toHex(fee.multiply(10_000).quotient)\n}\n","import invariant from 'tiny-invariant'\nimport { ethers } from 'ethers'\nimport { PermitSingle } from '@uniswap/permit2-sdk'\nimport { CommandType, RoutePlanner } from './routerCommands'\nimport { OPENSEA_CONDUIT_SPENDER_ID, ROUTER_AS_RECIPIENT, SUDOSWAP_SPENDER_ID } from './constants'\n\nexport interface Permit2Permit extends PermitSingle {\n  signature: string\n}\n\nexport type ApproveProtocol = {\n  token: string\n  protocol: string\n}\n\nexport type Permit2TransferFrom = {\n  token: string\n  amount: string\n  recipient?: string\n}\n\nexport type InputTokenOptions = {\n  approval?: ApproveProtocol\n  permit2Permit?: Permit2Permit\n  permit2TransferFrom?: Permit2TransferFrom\n}\n\nconst SIGNATURE_LENGTH = 65\nconst EIP_2098_SIGNATURE_LENGTH = 64\n\nexport function encodePermit(planner: RoutePlanner, permit2: Permit2Permit): void {\n  let signature = permit2.signature\n\n  const length = ethers.utils.arrayify(permit2.signature).length\n  // signature data provided for EIP-1271 may have length different from ECDSA signature\n  if (length === SIGNATURE_LENGTH || length === EIP_2098_SIGNATURE_LENGTH) {\n    // sanitizes signature to cover edge cases of malformed EIP-2098 sigs and v used as recovery id\n    signature = ethers.utils.joinSignature(ethers.utils.splitSignature(permit2.signature))\n  }\n\n  planner.addCommand(CommandType.PERMIT2_PERMIT, [permit2, signature])\n}\n\n// Handles the encoding of commands needed to gather input tokens for a trade\n// Approval: The router approving another address to take tokens.\n//   note: Only seaport and sudoswap support this action. Approvals are left open.\n// Permit: A Permit2 signature-based Permit to allow the router to access a user's tokens\n// Transfer: A Permit2 TransferFrom of tokens from a user to either the router or another address\nexport function encodeInputTokenOptions(planner: RoutePlanner, options: InputTokenOptions) {\n  // first ensure that all tokens provided for encoding are the same\n  if (!!options.approval && !!options.permit2Permit)\n    invariant(options.approval.token === options.permit2Permit.details.token, `inconsistent token`)\n  if (!!options.approval && !!options.permit2TransferFrom)\n    invariant(options.approval.token === options.permit2TransferFrom.token, `inconsistent token`)\n  if (!!options.permit2TransferFrom && !!options.permit2Permit)\n    invariant(options.permit2TransferFrom.token === options.permit2Permit.details.token, `inconsistent token`)\n\n  // if an options.approval is required, add it\n  if (!!options.approval) {\n    planner.addCommand(CommandType.APPROVE_ERC20, [\n      options.approval.token,\n      mapApprovalProtocol(options.approval.protocol),\n    ])\n  }\n\n  // if this order has a options.permit2Permit, encode it\n  if (!!options.permit2Permit) {\n    encodePermit(planner, options.permit2Permit)\n  }\n\n  if (!!options.permit2TransferFrom) {\n    planner.addCommand(CommandType.PERMIT2_TRANSFER_FROM, [\n      options.permit2TransferFrom.token,\n      options.permit2TransferFrom.recipient ? options.permit2TransferFrom.recipient : ROUTER_AS_RECIPIENT,\n      options.permit2TransferFrom.amount,\n    ])\n  }\n}\n\nfunction mapApprovalProtocol(protocolAddress: string): number {\n  switch (protocolAddress.toLowerCase()) {\n    case '0x00000000000000adc04c56bf30ac9d3c0aaf14dc': // Seaport v1.5\n      return OPENSEA_CONDUIT_SPENDER_ID\n    case '0x00000000000001ad428e4906ae43d8f9852d0dd6': // Seaport v1.4\n      return OPENSEA_CONDUIT_SPENDER_ID\n    case '0x2b2e8cda09bba9660dca5cb6233787738ad68329': // Sudoswap\n      return SUDOSWAP_SPENDER_ID\n    default:\n      throw new Error('unsupported protocol address')\n  }\n}\n","import invariant from 'tiny-invariant'\nimport UniversalRouter from '@uniswap/universal-router/artifacts/contracts/UniversalRouter.sol/UniversalRouter.json'\nconst { abi } = UniversalRouter\nimport { Interface } from '@ethersproject/abi'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { MethodParameters } from '@uniswap/v3-sdk'\nimport { Trade as RouterTrade } from '@uniswap/router-sdk'\nimport { Currency, TradeType } from '@uniswap/sdk-core'\nimport { Command, RouterTradeType } from './entities/Command'\nimport { Market, NFTTrade, SupportedProtocolsData } from './entities/NFTTrade'\nimport { UniswapTrade, SwapOptions } from './entities/protocols/uniswap'\nimport { UnwrapWETH } from './entities/protocols/unwrapWETH'\nimport { CommandType, RoutePlanner } from './utils/routerCommands'\nimport { encodePermit } from './utils/inputTokens'\nimport { ROUTER_AS_RECIPIENT, SENDER_AS_RECIPIENT, ETH_ADDRESS } from './utils/constants'\nimport { SeaportTrade } from './entities'\n\nexport type SwapRouterConfig = {\n  sender?: string // address\n  deadline?: BigNumberish\n}\n\ntype SupportedNFTTrade = NFTTrade<SupportedProtocolsData>\n\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  public static swapCallParameters(trades: Command[] | Command, config: SwapRouterConfig = {}): MethodParameters {\n    if (!Array.isArray(trades)) trades = [trades]\n\n    const nftTrades = trades.filter((trade, _, []) => trade.hasOwnProperty('market')) as SupportedNFTTrade[]\n    const allowRevert = nftTrades.length == 1 && nftTrades[0].orders.length == 1 ? false : true\n    const planner = new RoutePlanner()\n\n    // track value flow to require the right amount of native value\n    let currentNativeValueInRouter = BigNumber.from(0)\n    let transactionValue = BigNumber.from(0)\n\n    // tracks the input tokens (and ETH) used to buy NFTs to allow us to sweep\n    let nftInputTokens = new Set<string>()\n\n    for (const trade of trades) {\n      /**\n       * is NFTTrade\n       */\n      if (trade.tradeType == RouterTradeType.NFTTrade) {\n        const nftTrade = trade as SupportedNFTTrade\n        nftTrade.encode(planner, { allowRevert })\n        const tradePrice = nftTrade.getTotalPrice()\n\n        if (nftTrade.market == Market.Seaport) {\n          const seaportTrade = nftTrade as SeaportTrade\n          const seaportInputTokens = seaportTrade.getInputTokens()\n          seaportInputTokens.forEach((inputToken) => {\n            nftInputTokens.add(inputToken)\n          })\n        } else {\n          nftInputTokens.add(ETH_ADDRESS)\n        }\n\n        // send enough native value to contract for NFT purchase\n        if (currentNativeValueInRouter.lt(tradePrice)) {\n          transactionValue = transactionValue.add(tradePrice.sub(currentNativeValueInRouter))\n          currentNativeValueInRouter = BigNumber.from(0)\n        } else {\n          currentNativeValueInRouter = currentNativeValueInRouter.sub(tradePrice)\n        }\n        /**\n         * is UniswapTrade\n         */\n      } else if (trade.tradeType == RouterTradeType.UniswapTrade) {\n        const uniswapTrade = trade as UniswapTrade\n        const inputIsNative = uniswapTrade.trade.inputAmount.currency.isNative\n        const outputIsNative = uniswapTrade.trade.outputAmount.currency.isNative\n        const swapOptions = uniswapTrade.options\n\n        invariant(!(inputIsNative && !!swapOptions.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\n\n        if (!!swapOptions.inputTokenPermit) {\n          encodePermit(planner, swapOptions.inputTokenPermit)\n        }\n\n        if (inputIsNative) {\n          transactionValue = transactionValue.add(\n            BigNumber.from(uniswapTrade.trade.maximumAmountIn(swapOptions.slippageTolerance).quotient.toString())\n          )\n        }\n        // track amount of native currency in the router\n        if (outputIsNative && swapOptions.recipient == ROUTER_AS_RECIPIENT) {\n          currentNativeValueInRouter = currentNativeValueInRouter.add(\n            BigNumber.from(uniswapTrade.trade.minimumAmountOut(swapOptions.slippageTolerance).quotient.toString())\n          )\n        }\n        uniswapTrade.encode(planner, { allowRevert: false })\n        /**\n         * is UnwrapWETH\n         */\n      } else if (trade.tradeType == RouterTradeType.UnwrapWETH) {\n        const UnwrapWETH = trade as UnwrapWETH\n        trade.encode(planner, { allowRevert: false })\n        currentNativeValueInRouter = currentNativeValueInRouter.add(UnwrapWETH.amount)\n        /**\n         * else\n         */\n      } else {\n        throw 'trade must be of instance: UniswapTrade or NFTTrade'\n      }\n    }\n\n    // TODO: matches current logic for now, but should eventually only sweep for multiple NFT trades\n    // or NFT trades with potential slippage (i.e. sudo).\n    // Note: NFTXV2 sends excess ETH to the caller (router), not the specified recipient\n    nftInputTokens.forEach((inputToken) => {\n      planner.addCommand(CommandType.SWEEP, [inputToken, SENDER_AS_RECIPIENT, 0])\n    })\n    return SwapRouter.encodePlan(planner, transactionValue, config)\n  }\n\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * This version does not work correctly for Seaport ERC20->NFT purchases\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given swap.\n   * @param trades to produce call parameters for\n   */\n  public static swapNFTCallParameters(trades: SupportedNFTTrade[], config: SwapRouterConfig = {}): MethodParameters {\n    let planner = new RoutePlanner()\n    let totalPrice = BigNumber.from(0)\n\n    const allowRevert = trades.length == 1 && trades[0].orders.length == 1 ? false : true\n\n    for (const trade of trades) {\n      trade.encode(planner, { allowRevert })\n      totalPrice = totalPrice.add(trade.getTotalPrice())\n    }\n\n    planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0])\n    return SwapRouter.encodePlan(planner, totalPrice, config)\n  }\n\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapERC20CallParameters(\n    trades: RouterTrade<Currency, Currency, TradeType>,\n    options: SwapOptions\n  ): MethodParameters {\n    // TODO: use permit if signature included in swapOptions\n    const planner = new RoutePlanner()\n\n    const trade: UniswapTrade = new UniswapTrade(trades, options)\n\n    const inputCurrency = trade.trade.inputAmount.currency\n    invariant(!(inputCurrency.isNative && !!options.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\n\n    if (options.inputTokenPermit) {\n      encodePermit(planner, options.inputTokenPermit)\n    }\n\n    const nativeCurrencyValue = inputCurrency.isNative\n      ? BigNumber.from(trade.trade.maximumAmountIn(options.slippageTolerance).quotient.toString())\n      : BigNumber.from(0)\n\n    trade.encode(planner, { allowRevert: false })\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue, {\n      deadline: options.deadlineOrPreviousBlockhash ? BigNumber.from(options.deadlineOrPreviousBlockhash) : undefined,\n    })\n  }\n\n  /**\n   * Encodes a planned route into a method name and parameters for the Router contract.\n   * @param planner the planned route\n   * @param nativeCurrencyValue the native currency value of the planned route\n   * @param config the router config\n   */\n  private static encodePlan(\n    planner: RoutePlanner,\n    nativeCurrencyValue: BigNumber,\n    config: SwapRouterConfig = {}\n  ): MethodParameters {\n    const { commands, inputs } = planner\n    const functionSignature = !!config.deadline ? 'execute(bytes,bytes[],uint256)' : 'execute(bytes,bytes[])'\n    const parameters = !!config.deadline ? [commands, inputs, config.deadline] : [commands, inputs]\n    const calldata = SwapRouter.INTERFACE.encodeFunctionData(functionSignature, parameters)\n    return { calldata, value: nativeCurrencyValue.toHexString() }\n  }\n}\n","import { TradeConfig } from '../Command'\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type CryptopunkData = {\n  tokenId: BigNumberish\n  recipient: string\n  value: BigNumberish\n}\n\nexport class CryptopunkTrade extends NFTTrade<CryptopunkData> {\n  public static CRYPTOPUNK_ADDRESS: string = '0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb'\n\n  constructor(orders: CryptopunkData[]) {\n    super(Market.Cryptopunks, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      planner.addCommand(CommandType.CRYPTOPUNKS, [item.tokenId, item.recipient, item.value], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: CryptopunkTrade.CRYPTOPUNK_ADDRESS,\n        tokenId: item.tokenId,\n        tokenType: TokenType.Cryptopunk,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/Foundation.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type FoundationData = {\n  recipient: string\n  tokenAddress: string\n  tokenId: BigNumberish\n  price: BigNumberish\n  referrer: string // address\n}\n\nexport class FoundationTrade extends NFTTrade<FoundationData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: FoundationData[]) {\n    super(Market.Foundation, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const calldata = FoundationTrade.INTERFACE.encodeFunctionData('buyV2', [\n        item.tokenAddress,\n        item.tokenId,\n        item.price,\n        item.referrer,\n      ])\n      planner.addCommand(\n        CommandType.FOUNDATION,\n        [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\n        config.allowRevert\n      )\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: TokenType.ERC721,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.price)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/LooksRareV2.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber } from 'ethers'\nimport { ZERO_ADDRESS } from '../../utils/constants'\n\nexport type MakerOrder = {\n  quoteType: number\n  globalNonce: string\n  subsetNonce: string\n  orderNonce: string\n  strategyId: number\n  collectionType: number\n  collection: string\n  currency: string\n  signer: string\n  startTime: number\n  endTime: number\n  price: string\n  itemIds: string[]\n  amounts: string[]\n  additionalParameters: string\n}\n\nexport type TakerOrder = {\n  recipient: string\n  additionalParameters: string\n}\n\nexport type MerkleProof = {\n  value: string\n  position: number\n}\n\nexport type MerkleTree = {\n  root: string\n  proof: MerkleProof[]\n}\n\nexport type LRV2APIOrder = MakerOrder & {\n  id: string\n  hash: string\n  signature: string\n  createdAt: string\n  merkleRoot?: string\n  merkleProof?: MerkleProof[]\n  status: string\n}\n\nexport type LooksRareV2Data = {\n  apiOrder: LRV2APIOrder\n  taker: string\n}\n\nexport class LooksRareV2Trade extends NFTTrade<LooksRareV2Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n  private static ERC721_ORDER = 0\n\n  constructor(orders: LooksRareV2Data[]) {\n    super(Market.LooksRareV2, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    const { takerBids, makerOrders, makerSignatures, totalValue, merkleTrees } = this.refactorAPIData(this.orders)\n\n    let calldata\n    if (this.orders.length == 1) {\n      calldata = LooksRareV2Trade.INTERFACE.encodeFunctionData('executeTakerBid', [\n        takerBids[0],\n        makerOrders[0],\n        makerSignatures[0],\n        merkleTrees[0],\n        ZERO_ADDRESS, // affiliate\n      ])\n    } else {\n      calldata = LooksRareV2Trade.INTERFACE.encodeFunctionData('executeMultipleTakerBids', [\n        takerBids,\n        makerOrders,\n        makerSignatures,\n        merkleTrees,\n        ZERO_ADDRESS, // affiliate\n        false, // isAtomic (we deal with this in allowRevert)\n      ])\n    }\n\n    planner.addCommand(CommandType.LOOKS_RARE_V2, [totalValue, calldata], config.allowRevert)\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      const tokenAddress = item.apiOrder.collection\n      const tokenType =\n        item.apiOrder.collectionType == LooksRareV2Trade.ERC721_ORDER ? TokenType.ERC721 : TokenType.ERC1155\n      for (const tokenId of item.apiOrder.itemIds)\n        buyItems.push({\n          tokenAddress,\n          tokenId,\n          tokenType,\n        })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.apiOrder.price)\n    }\n    return total\n  }\n\n  private refactorAPIData(orders: LooksRareV2Data[]): {\n    takerBids: TakerOrder[]\n    makerOrders: MakerOrder[]\n    makerSignatures: string[]\n    totalValue: BigNumber\n    merkleTrees: MerkleTree[]\n  } {\n    let takerBids: TakerOrder[] = []\n    let makerOrders: MakerOrder[] = []\n    let makerSignatures: string[] = []\n    let totalValue: BigNumber = BigNumber.from(0)\n    let merkleTrees: MerkleTree[] = []\n\n    orders.forEach((order) => {\n      makerOrders.push({ ...order.apiOrder })\n\n      makerSignatures.push(order.apiOrder.signature)\n\n      takerBids.push({\n        recipient: order.taker,\n        additionalParameters: '0x',\n      })\n\n      totalValue = totalValue.add(BigNumber.from(order.apiOrder.price))\n\n      merkleTrees.push({\n        root: order.apiOrder.merkleRoot ?? '0x0000000000000000000000000000000000000000000000000000000000000000',\n        proof: order.apiOrder.merkleProof ?? [],\n      })\n    })\n\n    return { takerBids, makerOrders, makerSignatures, totalValue, merkleTrees }\n  }\n}\n","import abi from '../../../abis/NFT20.json'\nimport { Interface } from '@ethersproject/abi'\nimport { TradeConfig } from '../Command'\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type NFT20Data = {\n  tokenAddress: string\n  tokenIds: BigNumberish[]\n  tokenAmounts: BigNumberish[]\n  recipient: string\n  fee: BigNumberish\n  isV3: boolean\n  value: BigNumberish\n}\n\nexport class NFT20Trade extends NFTTrade<NFT20Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: NFT20Data[]) {\n    super(Market.NFT20, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = NFT20Trade.INTERFACE.encodeFunctionData('ethForNft', [\n        order.tokenAddress,\n        order.tokenIds,\n        order.tokenAmounts,\n        order.recipient,\n        order.fee,\n        order.isV3,\n      ])\n      planner.addCommand(CommandType.NFT20, [order.value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const pool of this.orders) {\n      for (const tokenId of pool.tokenIds) {\n        buyItems.push({\n          tokenAddress: pool.tokenAddress,\n          tokenId: tokenId,\n          tokenType: TokenType.ERC721,\n        })\n      }\n    }\n\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/NFTXZap.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type NFTXData = {\n  recipient: string\n  vaultId: BigNumberish\n  tokenAddress: string\n  tokenIds: BigNumberish[]\n  value: BigNumber\n  swapCalldata: string\n}\n\nexport class NFTXTrade extends NFTTrade<NFTXData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: NFTXData[]) {\n    super(Market.NFTX, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = NFTXTrade.INTERFACE.encodeFunctionData('buyAndRedeem', [\n        order.vaultId,\n        order.tokenIds.length,\n        order.tokenIds,\n        order.swapCalldata,\n        order.recipient,\n      ])\n\n      planner.addCommand(CommandType.NFTX, [order.value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const tokenId of order.tokenIds) {\n        buyItems.push({\n          tokenAddress: order.tokenAddress,\n          tokenId: tokenId,\n          tokenType: TokenType.ERC721,\n        })\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import { BigNumber, BigNumberish } from 'ethers'\nimport { Interface } from '@ethersproject/abi'\nimport abi from '../../../abis/Seaport.json'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { encodeInputTokenOptions, Permit2Permit } from '../../utils/inputTokens'\nimport { ETH_ADDRESS } from '../../utils/constants'\n\nexport type SeaportData = {\n  items: Order[]\n  recipient: string // address\n  protocolAddress: string\n  inputTokenProcessing?: InputTokenProcessing[]\n}\n\nexport type InputTokenProcessing = {\n  token: string\n  permit2Permit?: Permit2Permit\n  protocolApproval: boolean\n  permit2TransferFrom: boolean\n}\n\nexport type FulfillmentComponent = {\n  orderIndex: BigNumberish\n  itemIndex: BigNumberish\n}\n\nexport type OfferItem = {\n  itemType: BigNumberish // enum\n  token: string // address\n  identifierOrCriteria: BigNumberish\n  startAmount: BigNumberish\n  endAmount: BigNumberish\n}\n\nexport type ConsiderationItem = OfferItem & {\n  recipient: string\n}\n\nexport type Order = {\n  parameters: OrderParameters\n  signature: string\n}\n\ntype OrderParameters = {\n  offerer: string // address,\n  offer: OfferItem[]\n  consideration: ConsiderationItem[]\n  orderType: BigNumberish // enum\n  startTime: BigNumberish\n  endTime: BigNumberish\n  zoneHash: string // bytes32\n  zone: string // address\n  salt: BigNumberish\n  conduitKey: string // bytes32,\n  totalOriginalConsiderationItems: BigNumberish\n}\n\nexport type AdvancedOrder = Order & {\n  numerator: BigNumber // uint120\n  denominator: BigNumber // uint120\n  extraData: string // bytes\n}\n\nexport class SeaportTrade extends NFTTrade<SeaportData> {\n  public static INTERFACE: Interface = new Interface(abi)\n  public static OPENSEA_CONDUIT_KEY: string = '0x0000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f0000'\n\n  constructor(orders: SeaportData[]) {\n    super(Market.Seaport, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      let advancedOrders: AdvancedOrder[] = []\n      let orderFulfillments: FulfillmentComponent[][] = order.items.map((_, index) => [\n        { orderIndex: index, itemIndex: 0 },\n      ])\n      let considerationFulFillments: FulfillmentComponent[][] = this.getConsiderationFulfillments(order.items)\n\n      for (const item of order.items) {\n        const { advancedOrder } = this.getAdvancedOrderParams(item)\n        advancedOrders.push(advancedOrder)\n      }\n\n      let calldata: string\n      if (advancedOrders.length == 1) {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAdvancedOrder', [\n          advancedOrders[0],\n          [],\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\n          order.recipient,\n        ])\n      } else {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAvailableAdvancedOrders', [\n          advancedOrders,\n          [],\n          orderFulfillments,\n          considerationFulFillments,\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\n          order.recipient,\n          100, // TODO: look into making this a better number\n        ])\n      }\n\n      if (!!order.inputTokenProcessing) {\n        for (const inputToken of order.inputTokenProcessing)\n          encodeInputTokenOptions(planner, {\n            approval: inputToken.protocolApproval\n              ? { token: inputToken.token, protocol: order.protocolAddress }\n              : undefined,\n            permit2Permit: inputToken.permit2Permit,\n            permit2TransferFrom: inputToken.permit2TransferFrom\n              ? { token: inputToken.token, amount: this.getTotalOrderPrice(order, inputToken.token).toString() }\n              : undefined,\n          })\n      }\n\n      planner.addCommand(\n        this.commandMap(order.protocolAddress),\n        [this.getTotalOrderPrice(order, ETH_ADDRESS).toString(), calldata],\n        config.allowRevert\n      )\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const item of order.items) {\n        for (const offer of item.parameters.offer) {\n          buyItems.push({\n            tokenAddress: offer.token,\n            tokenId: offer.identifierOrCriteria,\n            tokenType: TokenType.ERC721,\n          })\n        }\n      }\n    }\n    return buyItems\n  }\n\n  getInputTokens(): Set<string> {\n    let inputTokens = new Set<string>()\n    for (const order of this.orders) {\n      for (const item of order.items) {\n        for (const consideration of item.parameters.consideration) {\n          const token = consideration.token.toLowerCase()\n          inputTokens.add(token)\n        }\n      }\n    }\n    return inputTokens\n  }\n\n  getTotalOrderPrice(order: SeaportData, token: string = ETH_ADDRESS): BigNumber {\n    let totalOrderPrice = BigNumber.from(0)\n    for (const item of order.items) {\n      totalOrderPrice = totalOrderPrice.add(this.calculateValue(item.parameters.consideration, token))\n    }\n    return totalOrderPrice\n  }\n\n  getTotalPrice(token: string = ETH_ADDRESS): BigNumber {\n    let totalPrice = BigNumber.from(0)\n    for (const order of this.orders) {\n      for (const item of order.items) {\n        totalPrice = totalPrice.add(this.calculateValue(item.parameters.consideration, token))\n      }\n    }\n    return totalPrice\n  }\n\n  private commandMap(protocolAddress: string): CommandType {\n    switch (protocolAddress.toLowerCase()) {\n      case '0x00000000000000adc04c56bf30ac9d3c0aaf14dc': // Seaport v1.5\n        return CommandType.SEAPORT_V1_5\n      case '0x00000000000001ad428e4906ae43d8f9852d0dd6': // Seaport v1.4\n        return CommandType.SEAPORT_V1_4\n      default:\n        throw new Error('unsupported Seaport address')\n    }\n  }\n\n  private getConsiderationFulfillments(protocolDatas: Order[]): FulfillmentComponent[][] {\n    let considerationFulfillments: FulfillmentComponent[][] = []\n    const considerationRecipients: string[] = []\n\n    for (const i in protocolDatas) {\n      const protocolData = protocolDatas[i]\n\n      for (const j in protocolData.parameters.consideration) {\n        const item = protocolData.parameters.consideration[j]\n\n        if (considerationRecipients.findIndex((x) => x === item.recipient) === -1) {\n          considerationRecipients.push(item.recipient)\n        }\n\n        const recipientIndex = considerationRecipients.findIndex((x) => x === item.recipient)\n\n        if (!considerationFulfillments[recipientIndex]) {\n          considerationFulfillments.push([\n            {\n              orderIndex: i,\n              itemIndex: j,\n            },\n          ])\n        } else {\n          considerationFulfillments[recipientIndex].push({\n            orderIndex: i,\n            itemIndex: j,\n          })\n        }\n      }\n    }\n    return considerationFulfillments\n  }\n\n  private getAdvancedOrderParams(data: Order): { advancedOrder: AdvancedOrder } {\n    const advancedOrder = {\n      parameters: data.parameters,\n      numerator: BigNumber.from('1'),\n      denominator: BigNumber.from('1'),\n      signature: data.signature,\n      extraData: '0x00',\n    }\n    return { advancedOrder }\n  }\n\n  private calculateValue(considerations: ConsiderationItem[], token: string): BigNumber {\n    return considerations.reduce(\n      (amt: BigNumber, consideration: ConsiderationItem) =>\n        consideration.token.toLowerCase() == token.toLowerCase() ? amt.add(consideration.startAmount) : amt,\n      BigNumber.from(0)\n    )\n  }\n}\n","import abi from '../../../abis/Sudoswap.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\ntype PairSwap = {\n  swapInfo: {\n    pair: string // address\n    nftIds: BigNumberish[]\n  }\n  tokenAddress: string // address\n  maxCost: BigNumberish\n}\n\nexport type SudoswapData = {\n  swaps: PairSwap[]\n  nftRecipient: string\n  ethRecipient: string\n  deadline: BigNumberish\n}\n\nexport class SudoswapTrade extends NFTTrade<SudoswapData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: SudoswapData[]) {\n    super(Market.Sudoswap, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = SudoswapTrade.INTERFACE.encodeFunctionData('robustSwapETHForSpecificNFTs', [\n        order.swaps.map((swap) => {\n          return { swapInfo: swap.swapInfo, maxCost: swap.maxCost }\n        }),\n        order.ethRecipient,\n        order.nftRecipient,\n        order.deadline,\n      ])\n      const value = order.swaps.reduce((prevVal, swap) => {\n        return prevVal.add(swap.maxCost)\n      }, BigNumber.from(0))\n      planner.addCommand(CommandType.SUDOSWAP, [value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const swap of order.swaps) {\n        for (const tokenId of swap.swapInfo.nftIds) {\n          buyItems.push({\n            tokenAddress: swap.tokenAddress,\n            tokenId,\n            tokenType: TokenType.ERC721,\n          })\n        }\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const order of this.orders) {\n      for (const swap of order.swaps) {\n        total = total.add(swap.maxCost)\n      }\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/X2Y2.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\ntype X2Y2PartialData = {\n  signedInput: string\n  recipient: string\n  tokenAddress: string\n  tokenId: BigNumberish\n  price: BigNumberish\n}\n\nexport type X2Y2_721_Data = X2Y2PartialData & {\n  tokenType: TokenType.ERC721\n}\n\nexport type X2Y2_1155_Data = X2Y2PartialData & {\n  tokenType: TokenType.ERC1155\n  tokenAmount: BigNumberish\n}\n\nexport type X2Y2Data = X2Y2_721_Data | X2Y2_1155_Data\n\nexport class X2Y2Trade extends NFTTrade<X2Y2Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: X2Y2Data[]) {\n    super(Market.X2Y2, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const functionSelector = X2Y2Trade.INTERFACE.getSighash(X2Y2Trade.INTERFACE.getFunction('run'))\n      const calldata = functionSelector + item.signedInput.slice(2)\n\n      if (item.tokenType == TokenType.ERC721) {\n        planner.addCommand(\n          CommandType.X2Y2_721,\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\n          config.allowRevert\n        )\n      } else if (item.tokenType == TokenType.ERC1155) {\n        planner.addCommand(\n          CommandType.X2Y2_1155,\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId, item.tokenAmount],\n          config.allowRevert\n        )\n      }\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: item.tokenType,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.price)\n    }\n    return total\n  }\n}\n","import { MixedRouteSDK, Trade as RouterTrade } from '@uniswap/router-sdk'\nimport { Currency, CurrencyAmount, Ether, Token, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2Route } from '@uniswap/v2-sdk'\nimport { Pool, Route as V3Route, FeeAmount } from '@uniswap/v3-sdk'\nimport { BigNumber } from 'ethers'\nimport { ETH_ADDRESS, E_ETH_ADDRESS } from './constants'\n\nexport type TokenInRoute = {\n  address: string\n  chainId: number\n  symbol: string\n  decimals: string\n  name?: string\n  buyFeeBps?: string\n  sellFeeBps?: string\n}\n\nexport enum PoolType {\n  V2Pool = 'v2-pool',\n  V3Pool = 'v3-pool',\n}\n\nexport type V2Reserve = {\n  token: TokenInRoute\n  quotient: string\n}\n\nexport type V2PoolInRoute = {\n  type: PoolType.V2Pool\n  address?: string\n  tokenIn: TokenInRoute\n  tokenOut: TokenInRoute\n  reserve0: V2Reserve\n  reserve1: V2Reserve\n  amountIn?: string\n  amountOut?: string\n}\n\nexport type V3PoolInRoute = {\n  type: PoolType.V3Pool\n  address?: string\n  tokenIn: TokenInRoute\n  tokenOut: TokenInRoute\n  sqrtRatioX96: string\n  liquidity: string\n  tickCurrent: string\n  fee: string\n  amountIn?: string\n  amountOut?: string\n}\n\nexport type PartialClassicQuote = {\n  // We need tokenIn/Out to support native currency\n  tokenIn: string\n  tokenOut: string\n  tradeType: TradeType\n  route: Array<(V3PoolInRoute | V2PoolInRoute)[]>\n}\n\ninterface RouteResult {\n  routev3: V3Route<Currency, Currency> | null\n  routev2: V2Route<Currency, Currency> | null\n  mixedRoute: MixedRouteSDK<Currency, Currency> | null\n  inputAmount: CurrencyAmount<Currency>\n  outputAmount: CurrencyAmount<Currency>\n}\n\nexport const isNativeCurrency = (address: string) =>\n  address.toLowerCase() === ETH_ADDRESS.toLowerCase() || address.toLowerCase() === E_ETH_ADDRESS.toLowerCase()\n\n// Helper class to convert routing-specific quote entities to RouterTrade entities\n// the returned RouterTrade can then be used to build the UniswapTrade entity in this package\nexport class RouterTradeAdapter {\n  // Generate a RouterTrade using fields from a classic quote response\n  static fromClassicQuote(quote: PartialClassicQuote) {\n    const { route, tokenIn, tokenOut } = quote\n\n    if (!route) throw new Error('Expected route to be present')\n    if (!route.length) throw new Error('Expected there to be at least one route')\n    if (route.some((r) => !r.length)) throw new Error('Expected all routes to have at least one pool')\n    const firstRoute = route[0]\n\n    const tokenInData = firstRoute[0].tokenIn\n    const tokenOutData = firstRoute[firstRoute.length - 1].tokenOut\n\n    if (!tokenInData || !tokenOutData) throw new Error('Expected both tokenIn and tokenOut to be present')\n    if (tokenInData.chainId !== tokenOutData.chainId)\n      throw new Error('Expected tokenIn and tokenOut to be have same chainId')\n\n    const parsedCurrencyIn = RouterTradeAdapter.toCurrency(isNativeCurrency(tokenIn), tokenInData)\n    const parsedCurrencyOut = RouterTradeAdapter.toCurrency(isNativeCurrency(tokenOut), tokenOutData)\n\n    const typedRoutes: RouteResult[] = route.map((subRoute) => {\n      const rawAmountIn = subRoute[0].amountIn\n      const rawAmountOut = subRoute[subRoute.length - 1].amountOut\n\n      if (!rawAmountIn || !rawAmountOut) {\n        throw new Error('Expected both raw amountIn and raw amountOut to be present')\n      }\n\n      const inputAmount = CurrencyAmount.fromRawAmount(parsedCurrencyIn, rawAmountIn)\n      const outputAmount = CurrencyAmount.fromRawAmount(parsedCurrencyOut, rawAmountOut)\n\n      const isOnlyV2 = RouterTradeAdapter.isVersionedRoute<V2PoolInRoute>(PoolType.V2Pool, subRoute)\n      const isOnlyV3 = RouterTradeAdapter.isVersionedRoute<V3PoolInRoute>(PoolType.V3Pool, subRoute)\n\n      return {\n        routev3: isOnlyV3\n          ? new V3Route(\n              (subRoute as V3PoolInRoute[]).map(RouterTradeAdapter.toPool),\n              parsedCurrencyIn,\n              parsedCurrencyOut\n            )\n          : null,\n        routev2: isOnlyV2\n          ? new V2Route(\n              (subRoute as V2PoolInRoute[]).map(RouterTradeAdapter.toPair),\n              parsedCurrencyIn,\n              parsedCurrencyOut\n            )\n          : null,\n        mixedRoute:\n          !isOnlyV3 && !isOnlyV2\n            ? new MixedRouteSDK(subRoute.map(RouterTradeAdapter.toPoolOrPair), parsedCurrencyIn, parsedCurrencyOut)\n            : null,\n        inputAmount,\n        outputAmount,\n      }\n    })\n\n    return new RouterTrade({\n      v2Routes: typedRoutes\n        .filter((route) => route.routev2)\n        .map((route) => ({\n          routev2: route.routev2 as V2Route<Currency, Currency>,\n          inputAmount: route.inputAmount,\n          outputAmount: route.outputAmount,\n        })),\n      v3Routes: typedRoutes\n        .filter((route) => route.routev3)\n        .map((route) => ({\n          routev3: route.routev3 as V3Route<Currency, Currency>,\n          inputAmount: route.inputAmount,\n          outputAmount: route.outputAmount,\n        })),\n      mixedRoutes: typedRoutes\n        .filter((route) => route.mixedRoute)\n        .map((route) => ({\n          mixedRoute: route.mixedRoute as MixedRouteSDK<Currency, Currency>,\n          inputAmount: route.inputAmount,\n          outputAmount: route.outputAmount,\n        })),\n      tradeType: quote.tradeType,\n    })\n  }\n\n  private static toCurrency(isNative: boolean, token: TokenInRoute): Currency {\n    if (isNative) {\n      return Ether.onChain(token.chainId)\n    }\n    return this.toToken(token)\n  }\n\n  private static toPoolOrPair = (pool: V3PoolInRoute | V2PoolInRoute): Pool | Pair => {\n    return pool.type === PoolType.V3Pool ? RouterTradeAdapter.toPool(pool) : RouterTradeAdapter.toPair(pool)\n  }\n\n  private static toToken(token: TokenInRoute): Token {\n    const { chainId, address, decimals, symbol, buyFeeBps, sellFeeBps } = token\n    return new Token(\n      chainId,\n      address,\n      parseInt(decimals.toString()),\n      symbol,\n      /* name */ undefined,\n      false,\n      buyFeeBps ? BigNumber.from(buyFeeBps) : undefined,\n      sellFeeBps ? BigNumber.from(sellFeeBps) : undefined\n    )\n  }\n\n  private static toPool({ fee, sqrtRatioX96, liquidity, tickCurrent, tokenIn, tokenOut }: V3PoolInRoute): Pool {\n    return new Pool(\n      RouterTradeAdapter.toToken(tokenIn),\n      RouterTradeAdapter.toToken(tokenOut),\n      parseInt(fee) as FeeAmount,\n      sqrtRatioX96,\n      liquidity,\n      parseInt(tickCurrent)\n    )\n  }\n\n  private static toPair = ({ reserve0, reserve1 }: V2PoolInRoute): Pair => {\n    return new Pair(\n      CurrencyAmount.fromRawAmount(RouterTradeAdapter.toToken(reserve0.token), reserve0.quotient),\n      CurrencyAmount.fromRawAmount(RouterTradeAdapter.toToken(reserve1.token), reserve1.quotient)\n    )\n  }\n\n  private static isVersionedRoute<T extends V2PoolInRoute | V3PoolInRoute>(\n    type: PoolType,\n    route: (V3PoolInRoute | V2PoolInRoute)[]\n  ): route is T[] {\n    return route.every((pool) => pool.type === type)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { BigNumberish } from 'ethers'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { encodeInputTokenOptions, Permit2Permit } from '../../utils/inputTokens'\nimport { Command, RouterTradeType, TradeConfig } from '../Command'\nimport { ROUTER_AS_RECIPIENT, WETH_ADDRESS } from '../../utils/constants'\n\nexport class UnwrapWETH implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.UnwrapWETH\n  readonly permit2Data: Permit2Permit\n  readonly wethAddress: string\n  readonly amount: BigNumberish\n\n  constructor(amount: BigNumberish, chainId: number, permit2?: Permit2Permit) {\n    this.wethAddress = WETH_ADDRESS(chainId)\n    this.amount = amount\n\n    if (!!permit2) {\n      invariant(\n        permit2.details.token.toLowerCase() === this.wethAddress.toLowerCase(),\n        `must be permitting WETH address: ${this.wethAddress}`\n      )\n      invariant(permit2.details.amount >= amount, `Did not permit enough WETH for unwrapWETH transaction`)\n      this.permit2Data = permit2\n    }\n  }\n\n  encode(planner: RoutePlanner, _: TradeConfig): void {\n    encodeInputTokenOptions(planner, {\n      permit2Permit: this.permit2Data,\n      permit2TransferFrom: {\n        token: this.wethAddress,\n        amount: this.amount.toString(),\n      },\n    })\n    planner.addCommand(CommandType.UNWRAP_WETH, [ROUTER_AS_RECIPIENT, this.amount])\n  }\n}\n"],"names":["RouterTradeType","Market","TokenType","CommandType","NFTTrade","market","orders","this","length","invariant","REVERTIBLE_COMMANDS","Set","SEAPORT_V1_5","SEAPORT_V1_4","NFTX","LOOKS_RARE_V2","X2Y2_721","X2Y2_1155","FOUNDATION","SUDOSWAP","NFT20","EXECUTE_SUB_PLAN","CRYPTOPUNKS","ELEMENT_MARKET","ABI_DEFINITION","_ABI_DEFINITION","PERMIT2_PERMIT","PERMIT2_PERMIT_BATCH","PERMIT2_TRANSFER_FROM","PERMIT2_TRANSFER_FROM_BATCH","PERMIT2_TRANSFER_FROM_STRUCT","V3_SWAP_EXACT_IN","V3_SWAP_EXACT_OUT","V2_SWAP_EXACT_IN","V2_SWAP_EXACT_OUT","WRAP_ETH","UNWRAP_WETH","SWEEP","SWEEP_ERC721","SWEEP_ERC1155","TRANSFER","PAY_PORTION","BALANCE_CHECK_ERC20","OWNER_CHECK_721","OWNER_CHECK_1155","APPROVE_ERC20","RoutePlanner","commands","inputs","_proto","prototype","addSubPlan","subplan","addCommand","type","parameters","allowRevert","command","encodedInput","defaultAbiCoder","encode","createCommand","push","has","Error","concat","toString","padStart","CHAIN_CONFIGS","_CHAIN_CONFIGS","router","weth","creationBlock","WETH_ADDRESS","chainId","CONTRACT_BALANCE","BigNumber","from","pow","ETH_ADDRESS","ZERO_ADDRESS","SENDER_AS_RECIPIENT","ROUTER_AS_RECIPIENT","REFUND_ETH_PRICE_IMPACT_THRESHOLD","Percent","UniswapTrade","trade","options","fee","flatFee","payerIsUser","inputRequiresWrap","useRouterBalance","planner","_config","maximumAmountIn","slippageTolerance","quotient","recipient","_this$options$recipie","swapOptions","_step","outputIsNative","outputAmount","currency","isNative","routerMustCustody","tradeType","TradeType","EXACT_INPUT","routes","_iterator","_createForOfIteratorHelperLoose","swaps","done","swap","value","route","protocol","Protocol","V2","addV2Swap","V3","addV3Swap","MIXED","addMixedSwap","minimumAmountOut","feeBips","toHex","multiply","wrapped","address","EXACT_OUTPUT","sub","mul","div","feeAmount","amount","lt","priceImpact","greaterThan","safeMode","key","get","inputAmount","_ref","V2Trade","path","map","pool","_ref2","V3Trade","createUncheckedTrade","encodeRouteToPath","tradeRecipient","pools","Pool","Pair","outputToken","MixedRouteTrade","amountIn","amountOut","sections","partitionMixedRouteByProtocol","isLastSectionInRoute","i","inputToken","input","section","getOutputOfPools","newRouteOriginal","MixedRouteSDK","token0","equals","token1","newRoute","MixedRoute","every","mixedRouteIsAllV3","encodeMixedRouteToPath","liquidityToken","encodePermit","permit2","signature","ethers","utils","arrayify","joinSignature","splitSignature","encodeInputTokenOptions","approval","permit2Permit","token","details","permit2TransferFrom","mapApprovalProtocol","protocolAddress","toLowerCase","abi","UniversalRouter","SwapRouter","swapCallParameters","trades","config","Array","isArray","nftTrades","filter","_","hasOwnProperty","currentNativeValueInRouter","transactionValue","nftInputTokens","nftTrade","tradePrice","getTotalPrice","Seaport","getInputTokens","forEach","add","uniswapTrade","inputIsNative","inputTokenPermit","UnwrapWETH","encodePlan","swapNFTCallParameters","_step2","totalPrice","_iterator2","swapERC20CallParameters","inputCurrency","nativeCurrencyValue","deadline","deadlineOrPreviousBlockhash","undefined","calldata","INTERFACE","encodeFunctionData","toHexString","Interface","CryptopunkTrade","_NFTTrade","call","Cryptopunks","_inheritsLoose","item","tokenId","getBuyItems","buyItems","tokenAddress","CRYPTOPUNK_ADDRESS","tokenType","Cryptopunk","_step3","total","_iterator3","FoundationTrade","Foundation","price","referrer","ERC721","LooksRareV2Trade","LooksRareV2","_this$refactorAPIData","refactorAPIData","takerBids","makerOrders","makerSignatures","totalValue","merkleTrees","apiOrder","collection","collectionType","ERC721_ORDER","ERC1155","itemIds","order","_extends","taker","additionalParameters","root","_order$apiOrder$merkl","merkleRoot","proof","_order$apiOrder$merkl2","merkleProof","NFT20Trade","tokenIds","tokenAmounts","isV3","_step4","_iterator4","NFTXTrade","vaultId","swapCalldata","SeaportTrade","advancedOrders","orderFulfillments","items","index","orderIndex","itemIndex","considerationFulFillments","getConsiderationFulfillments","_this$getAdvancedOrde","getAdvancedOrderParams","advancedOrder","OPENSEA_CONDUIT_KEY","inputTokenProcessing","protocolApproval","getTotalOrderPrice","commandMap","_step5","_iterator5","_step6","_iterator6","offer","identifierOrCriteria","_step7","inputTokens","_iterator7","_step8","_iterator8","_step9","_iterator9","consideration","_step10","totalOrderPrice","_iterator10","calculateValue","_step11","_iterator11","_step12","_iterator12","protocolDatas","considerationFulfillments","considerationRecipients","protocolData","_loop","j","findIndex","x","recipientIndex","data","numerator","denominator","extraData","considerations","reduce","amt","startAmount","SudoswapTrade","Sudoswap","swapInfo","maxCost","ethRecipient","nftRecipient","prevVal","nftIds","X2Y2Trade","X2Y2","getSighash","getFunction","signedInput","slice","tokenAmount","PoolType","wethAddress","permit2Data","isNativeCurrency","RouterTradeAdapter","fromClassicQuote","quote","tokenIn","tokenOut","some","r","firstRoute","tokenInData","tokenOutData","parsedCurrencyIn","toCurrency","parsedCurrencyOut","typedRoutes","subRoute","rawAmountIn","rawAmountOut","CurrencyAmount","fromRawAmount","isOnlyV2","isVersionedRoute","V2Pool","isOnlyV3","V3Pool","routev3","V3Route","toPool","routev2","V2Route","toPair","mixedRoute","toPoolOrPair","RouterTrade","v2Routes","v3Routes","mixedRoutes","Ether","onChain","toToken","symbol","buyFeeBps","sellFeeBps","Token","parseInt","decimals","sqrtRatioX96","liquidity","tickCurrent","reserve0","reserve1"],"mappings":"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"}